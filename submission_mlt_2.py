# -*- coding: utf-8 -*-
"""Submission_MLT_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fh5GMGNQqdnCPqNuv4z0EhLevt1b3RMJ

# Proyek Machine Learning: Sistem Rekomendasi Game Steam

## Import Library
"""

# Commented out IPython magic to ensure Python compatibility.
!pip install tensorflow
!pip install graphviz
!pip install pydot
# Library umum
import shutil
import os
import zipfile
from ast import literal_eval
import kagglehub
import warnings
warnings.filterwarnings('ignore')
import pydot
import graphviz
# Library Visualisasi dan analisis Data
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import seaborn as sns
# %matplotlib inline

# Library deep learning
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.layers import Input, Embedding, Dot, Add, Flatten
from tensorflow.keras.models import Model
from tensorflow.keras.regularizers import l2
from tensorflow.keras.optimizers import Adam
from tensorflow.keras import layers

# Library pemrosesan dan metrik
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from google.colab import files

files.upload()

!mkdir ~/.kaggle/
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json
!kaggle datasets download -d antonkozyriev/game-recommendations-on-steam --force
!unzip game-recommendations-on-steam.zip

"""## Data Loading"""

game_df = pd.read_csv('games.csv')
user_df = pd.read_csv('users.csv')
recommend_df = pd.read_csv('recommendations.csv')
games_metadata_df = pd.read_json('games_metadata.json', lines=True)

"""Melakukan drop data yang mengalami missing value

## Eksplorasi Data dan Visualisasi (EDA)

## Deksripsi Data
"""

games_metadata_df.head()

games_metadata_df.info()

games_metadata_df.describe()

game_df.head()

game_df.info()

game_df.describe()

user_df.head()

user_df.info()

user_df.describe()

recommend_df.head()

recommend_df.info()

recommend_df.describe()

dataframes = {
    'game_df' : game_df,
    'users_df' : user_df,
    'recommend_df' : recommend_df,
    'games_metadata_df': games_metadata_df
}

# Checking null values
for name, df in dataframes.items():
    print(f"\nNull values in {name} :\n{df.isna().sum()}")

    # Dimension of dataframe
    df_dimension = df.shape

    print(f"Dimension of {name}: {df_dimension}")

n_games = game_df.nunique()
n_users = user_df.nunique()

unique_review_values = recommend_df['is_recommended'].unique()

print('\nNumber of unique values in game_df: ', n_games)

print('Number of unique values in users_df: ', n_users)
print("Unique Review values (is_recommended) : ", unique_review_values)

"""## Unvariate Analysis"""

# Menentukan rentang rating yang ingin dikelompokkan (dimulai dari 10)
bins = [10, 30, 50, 70, 90, 100]  # Batasan rentang rating
labels = ['10-30', '30-50', '50-70', '70-90', '90-100']  # Label untuk setiap rentang

# Mengelompokkan data berdasarkan rentang rating
game_df['rating_group'] = pd.cut(game_df['positive_ratio'], bins=bins, labels=labels, right=False)

# Menghitung jumlah game di setiap kelompok
rating_distribution = game_df['rating_group'].value_counts(normalize=True) * 100  # Menghitung persentase

# Menentukan urutan kategori yang diinginkan pada sumbu X
rating_distribution = rating_distribution[['90-100', '70-90', '50-70', '30-50', '10-30']]

# Menampilkan distribusi rating dalam bentuk bar chart
plt.figure(figsize=(10, 6))
rating_distribution.plot(kind='bar', color='skyblue')
plt.title('Distribusi Rating Game Berdasarkan Rentang Rating Positif')
plt.xlabel('Rentang Rating Positif')
plt.ylabel('Persentase Game (%)')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""Insight:

1. **Rentang Rating 70-90**  
   Rating **70-90** merupakan rentang rating yang paling banyak ditemui, dengan persentase tertinggi sekitar **40%**. Ini menunjukkan bahwa sebagian besar game mendapatkan ulasan positif, tetapi tidak sepenuhnya mendapatkan rating luar biasa. Banyak game yang cukup sukses namun tidak mencapai kualitas yang sangat luar biasa di mata pemain.

2. **Rentang Rating 90-100**  
   Disusul oleh rating **90-100** dengan persentase sekitar **20%**. Ini menunjukkan bahwa sejumlah game berhasil mendapatkan penerimaan luar biasa dari pemain, menandakan kualitas gameplay, grafis, dan dukungan teknis yang sangat memuaskan.

3. **Rentang Rating 50-70**  
   Rating **50-70** mengikutinya dengan persentase sekitar **15%**. Hal ini menunjukkan bahwa ada sebagian kecil game yang mendapatkan penilaian cukup baik, namun masih ada ruang untuk perbaikan dalam hal fitur atau gameplay untuk memuaskan lebih banyak pemain.

4. **Rentang Rating 30-50**  
   Rentang **30-50** mencatat sekitar **10%** game. Ini menunjukkan bahwa ada game yang dianggap cukup biasa atau memiliki kekurangan yang signifikan dalam hal kualitas atau pengalaman pengguna.

5. **Rentang Rating 10-30**  
   Rentang **10-30** hanya mencatat sekitar **5%** game, menunjukkan bahwa sedikit sekali game yang menerima rating sangat rendah. Game dengan rating ini kemungkinan besar memiliki masalah yang sangat mendalam, seperti bug besar atau desain yang buruk.
"""

# Menggabungkan games_df dan games_metadata_df berdasarkan 'app_id' sebagai foreign key
games_with_metadata = pd.merge(game_df, games_metadata_df, on='app_id', how='left')

# Meledakkan genre-genre tersebut ke dalam baris-baris terpisah
exploded_genres = games_with_metadata.explode('tags')

# Membersihkan spasi di sekitar nama genre
exploded_genres['tags'] = exploded_genres['tags'].str.strip()

# Menghitung jumlah game di setiap genre
genre_distribution = exploded_genres['tags'].value_counts()

# Menampilkan top 10 genre berdasarkan jumlah game
top_10_genre_distribution = genre_distribution.head(10)

# Menampilkan distribusi jumlah game per genre dalam bentuk bar chart
plt.figure(figsize=(12, 8))
top_10_genre_distribution.plot(kind='bar', color='skyblue')
plt.title('Top 10 Genre dengan Jumlah Game Terbanyak')
plt.xlabel('Genre')
plt.ylabel('Jumlah Game')
plt.xticks(rotation=45, ha='right')  # Memutar label agar lebih mudah dibaca
plt.tight_layout()
plt.show()

"""**Insight:**

1. **Genre "Indie"**
   - **Genre "Indie"** merupakan genre dengan jumlah game terbanyak, dengan **lebih dari 25.000 game**. Ini menunjukkan bahwa genre ini sangat dominan di Steam, dengan banyak pengembang indie yang merilis game mereka di platform ini.
   - **Interpretasi**: Genre **Indie** menggambarkan tren dalam industri game, di mana banyak pengembang kecil dan independen yang berhasil meraih kesuksesan di platform digital. Ini juga mencerminkan bahwa pemain sangat tertarik dengan game kreatif dengan anggaran terbatas.

2. **Genre "Singleplayer"**
   - **Singleplayer** mencatatkan sekitar **20.000 game**, menjadikannya salah satu genre terpopuler di Steam. Genre ini menunjukkan bahwa banyak game yang berfokus pada pengalaman pemain tunggal.
   - **Interpretasi**: Kecenderungan ini menunjukkan bahwa banyak pemain lebih memilih pengalaman bermain yang mendalam, di mana mereka dapat menikmati cerita dan gameplay tanpa bergantung pada orang lain.

3. **Genre "Action"**
   - **Action** juga mencatatkan sekitar **20.000 game**, menjadikannya genre yang sangat banyak diminati. Genre ini menunjukkan banyaknya game dengan fokus pada aksi dan dinamika gameplay yang cepat.
   - **Interpretasi**: Genre **Action** sangat populer karena menawarkan pengalaman bermain yang intens dan mengasyikkan bagi para pemain yang mencari tantangan dan adrenalin.

4. **Genre "Adventure"**
   - **Adventure** berada di posisi keempat dengan lebih dari **15.000 game**. Genre ini berfokus pada eksplorasi dan cerita yang mendalam, yang memberikan pengalaman imersif bagi pemain.
   - **Interpretasi**: Genre **Adventure** mencerminkan popularitas game dengan cerita yang kuat dan dunia yang kaya, di mana pemain dapat merasakan petualangan dan pengembangan karakter yang mendalam.

5. **Genre "Casual"**
   - **Casual** mencatatkan lebih dari **10.000 game**, menunjukkan bahwa banyak pemain yang menikmati game dengan gameplay yang ringan dan mudah diakses.
   - **Interpretasi**: Genre **Casual** sangat populer di kalangan pemain yang mencari game yang tidak terlalu menuntut dan cocok dimainkan dalam waktu singkat.

6. **Genre "Simulation"**
   - **Simulation** dengan lebih dari **10.000 game** menunjukkan bahwa genre ini banyak diminati oleh pemain yang tertarik pada simulasi kehidupan atau sistem yang realistis.
   - **Interpretasi**: Genre **Simulation** menawarkan pengalaman bermain yang lebih santai dan kreatif, di mana pemain dapat menciptakan atau mengelola sesuatu sesuai dengan skenario tertentu.

7. **Genre "2D"**
   - **2D** muncul dengan lebih dari **5.000 game**. Genre ini berfokus pada gameplay dengan tampilan dua dimensi, menawarkan pengalaman yang lebih sederhana dan nostalgik.
   - **Interpretasi**: Genre **2D** tetap populer karena gameplay-nya yang mudah diakses dan fokus pada estetika dan desain yang unik.

8. **Genre "Strategy"**
   - **Strategy** memiliki lebih dari **5.000 game**, mencerminkan banyaknya game yang mengutamakan perencanaan dan taktik.
   - **Interpretasi**: Genre **Strategy** sangat dihargai oleh pemain yang menyukai tantangan mental dan pengambilan keputusan yang mendalam.

9. **Genre "RPG"**
   - **RPG (Role-Playing Game)** dengan lebih dari **5.000 game** juga menunjukkan bahwa genre ini memiliki audiens yang besar, dengan pengalaman bermain yang lebih berfokus pada cerita dan pengembangan karakter.
   - **Interpretasi**: Genre **RPG** sangat populer di kalangan pemain yang suka menjelajahi dunia fantasi dan membangun karakter mereka dari awal.

10. **Genre "Atmospheric"**
   - **Atmospheric** menempati posisi terakhir dengan lebih dari **5.000 game**, mengindikasikan banyaknya game yang menekankan pada suasana dan visual yang mendalam.
   - **Interpretasi**: Genre **Atmospheric** menarik pemain yang ingin merasakan pengalaman visual dan emosional yang lebih mendalam, dengan fokus pada atmosfer yang memengaruhi pengalaman gameplay secara keseluruhan.

## Data Preparation
"""

# Jika perlu mengganti nilai yang tidak sesuai dalam kolom produk
user_df['products'] = user_df['products'].apply(lambda x: x if x > 0 else None)


# Menyaring nilai yang tidak valid (misalnya produk dan ulasan yang kosong atau tidak sesuai)
game_df.dropna(subset=['price_final', 'price_original'], inplace=True)
user_df.dropna(subset=['products'], inplace=True)

# 4. Verifikasi data setelah pembersihan
print("Cleaned data for game_df:")
print(game_df.head())
print("Cleaned data for users_df:")
print(user_df.head())

# Mengganti nilai kosong atau NaN di kolom 'description' dengan string kosong atau None
games_metadata_df['description'] = games_metadata_df['description'].apply(lambda x: x if pd.notnull(x) and x.strip() != '' else 'No Description')

# Mengganti array kosong pada kolom 'tags' dengan None atau list kosong
games_metadata_df['tags'] = games_metadata_df['tags'].apply(lambda x: x if len(x) > 0 else None)

# Memeriksa hasil setelah pembersihan
print(games_metadata_df.head())

# Menghapus baris dengan NaN di kolom 'tags' dan 'description'
games_metadata_df.dropna(subset=['tags', 'description'], inplace=True)

# Memeriksa hasil setelah drop NaN
print("Jumlah baris setelah pembersihan:", games_metadata_df.shape[0])
games_metadata_df

game_df = game_df[['app_id','title','positive_ratio']]
games_metadata_df = games_metadata_df[['app_id','tags']]

# Menggabungkan game_df dan games_metadata_df berdasarkan 'app_id'
df_games_rating = pd.merge(game_df, games_metadata_df, on='app_id', how='inner')
df_games_rating

df_games_rating_cbf = df_games_rating.copy().reset_index(drop=True)

# Konversi list menjadi string
df_games_rating_cbf['tags'] = df_games_rating_cbf['tags'].apply(lambda x: ' '.join(x) if isinstance(x, list) else x)

# Inisiasi objek TF-IDF Vectorizer dari sklearn
vectorizer = TfidfVectorizer()

# Transformasi teks genre menjadi matriks TF-IDF
tf_idf_matrix = vectorizer.fit_transform(df_games_rating_cbf['tags'])

# Menampilkan fitur/genre unik yang dihasilkan oleh TF-IDF setelah proses token
vectorizer.get_feature_names_out()

# Cek shape dari matriks tf_idfnya
tf_idf_matrix.shape

pd.DataFrame(
    tf_idf_matrix.toarray(),
    columns=vectorizer.get_feature_names_out(),
    index=df_games_rating_cbf['title']
)

df_games_rating_cf = df_games_rating.copy().reset_index(drop=True)

df_games_rating_cf = pd.merge(df_games_rating_cf, recommend_df, on='app_id', how='inner')
df_games_rating_cf = pd.merge(df_games_rating_cf, user_df, on='user_id', how='inner')
df_games_rating_cf

# Pilihlah fitur yang relevan untuk collaborative filtering
df_games_rating_cf = df_games_rating_cf[['app_id', 'user_id', 'positive_ratio']]

# urutkan datanya berdasarkan userId
df_games_rating_cf = df_games_rating_cf.sort_values(by='user_id')
df_games_rating_cf.nunique()

user_encoder = LabelEncoder()
game_encoder = LabelEncoder()


df_games_rating_cf['user'] = user_encoder.fit_transform(df_games_rating_cf['user_id'])
df_games_rating_cf['app'] = game_encoder.fit_transform(df_games_rating_cf['app_id'])


# Tampilkan Jumlah pengguna, Jumlah film, Minimum rating, dan Maksimum rating
print(f'Jumlah dari user --> {df_games_rating_cf["user"].nunique()}')
print(f'Jumlah dari games --> {df_games_rating_cf["app"].nunique()}')
print(f'Rating minimum --> {df_games_rating_cf["positive_ratio"].min()}')
print(f'Rating maksimum --> {df_games_rating_cf["positive_ratio"].max()}\n')

# Tampilkan data yang telah
df_games_rating_cf.head()

# Normalisasi rating ke rentang 0-1
min_rating = df_games_rating_cf['positive_ratio'].min()
max_rating = df_games_rating_cf['positive_ratio'].max()

df_games_rating_cf['positive_ratio_norm'] = (df_games_rating_cf['positive_ratio'] - min_rating) / (max_rating - min_rating)

# Memisahkan data menjadi 80% untuk training dan 20% untuk validasi dan testing
train_data, temp_data = train_test_split(df_games_rating_cf, test_size=0.2, random_state=42)

# Memisahkan 20% temp_data menjadi 10% validasi dan 10% testing
validation_data, test_data = train_test_split(temp_data, test_size=0.5, random_state=42)

# Menampilkan jumlah data untuk memastikan pembagian yang benar
print(f"Jumlah data untuk pelatihan: {len(train_data)}")
print(f"Jumlah data untuk validasi: {len(validation_data)}")
print(f"Jumlah data untuk pengujian: {len(test_data)}")

"""## Modeling

### Content-Based Filtering
"""

cosine_sim = cosine_similarity(tf_idf_matrix, tf_idf_matrix)
cosine_sim

cosine_df = pd.DataFrame(cosine_sim, columns=df_games_rating_cbf['title'], index=df_games_rating_cbf['title'])
cosine_df

def game_recommendations(game_name, similarity_data=cosine_sim, items=df_games_rating_cbf[['title', 'tags']], top_n=10):

    # Copy dataframe untuk mencegah perubahan pada data asli
    items = items.copy()

    # Pastikan case yang digunakan untuk pencarian film sama yaitu lower
    items['title_lower'] = items['title'].str.lower()
    game_name = game_name.lower()

    # Mencari indeks film yang ada di dalam similarity_data untuk film yang diberikan
    if game_name not in items['title_lower'].values:
        return f"Game '{game_name}' tidak ditemukan dalam data."

    game_index = items[items['title_lower'] == game_name].index[0]

    # Mengambil nilai cosine similarity untuk film yang dicari
    sim_scores = similarity_data[game_index]

    # Mengurutkan berdasarkan similarity, ambil k film teratas (k+1 karena index dimulai dari 0)
    similar_indices = sim_scores.argsort()[-(top_n+1):-1][::-1]

    # Mengambil nama film berdasarkan indeks
    similar_movies = items['title'].iloc[similar_indices]

    # Menampilkan dataframe dengan film yang direkomendasikan
    return pd.DataFrame(similar_movies).merge(items, on='title').head(top_n).drop(columns='title_lower')

df_games_rating_cbf[df_games_rating_cbf['title'] == 'Prince of Persia: Warrior Within™']

rekomendasi = game_recommendations('Prince of Persia: Warrior Within™')
rekomendasi

"""### Colaborative Filtering"""

# Ukuran vektor embedding
embedding_size = 50

# Input untuk user dan movie
user_input = Input(shape=(1,), name='user_input')
app_input = Input(shape=(1,), name='app_input')

# Embedding untuk user
user_embedding = Embedding(
    input_dim=df_games_rating_cf['user'].nunique(),
    output_dim=embedding_size,
    embeddings_initializer='he_normal',
    embeddings_regularizer=l2(1e-6)
)(user_input)

# Bias untuk user
user_bias = Embedding(
    input_dim=df_games_rating_cf['user'].nunique(),
    output_dim=1
)(user_input)

# Embedding untuk movie
app_embedding = Embedding(
    input_dim=df_games_rating_cf['app'].nunique(),
    output_dim=embedding_size,
    embeddings_initializer='he_normal',
    embeddings_regularizer=l2(1e-6)
)(app_input)

# Bias untuk movie
app_bias = Embedding(
    input_dim=df_games_rating_cf['app'].nunique(),
    output_dim=1
)(app_input)

# Dot product antara user dan movie embedding
dot_product = Dot(axes=2)([user_embedding, app_embedding])

# Tambahkan bias user dan movie ke hasil dot product
add_bias = Add()([dot_product, user_bias, app_bias])

# Flatten output
x = Flatten()(add_bias)

# Aktifkan output dengan sigmoid (karena target sudah dinormalisasi)
output = tf.keras.activations.sigmoid(x)

# Bangun model
model = Model(inputs=[user_input, app_input], outputs=output)

# Lihat ringkasan model
model.summary()

model.compile(
    loss=tf.keras.losses.MeanSquaredError(),
    optimizer=tf.keras.optimizers.Adam(),
    metrics=['mean_absolute_error', "root_mean_squared_error"])

# Pelatihan model
history = model.fit(
    x=[train_data['user'], train_data['app']],
    y=train_data['positive_ratio_norm'],
    batch_size=524288,
    epochs=5,
    verbose=1,
    validation_data=([validation_data['user'], validation_data['app']], validation_data['positive_ratio_norm']))

# Salin dataframe yang diperlukan
game_df = df_games_rating_cf.copy()
df = df_games_rating

# Ambil satu user secara acak
user_id = game_df['user_id'].sample(1).iloc[0]  # Ambil user ID secara acak
game_rated_by_user = game_df[game_df['user_id'] == user_id]

# Game yang belum pernah ditonton oleh user
games_not_watched = game_df[~game_df['app_id'].isin(game_rated_by_user['app_id'].values)]['app_id']
games_not_watched = list(
    set(games_not_watched)
    .intersection(set(game_encoder.classes_))  # Agar cocok dengan game yang sudah diencode
)

# Encode game dan user
games_not_watched_encoded = [[game_encoder.transform([x])[0]] for x in games_not_watched]
user_encoded = user_encoder.transform([user_id])[0]

# Input untuk model
user_input_array = np.array([user_encoded] * len(games_not_watched_encoded))
game_input_array = np.array([x[0] for x in games_not_watched_encoded])

# Prediksi rating untuk game yang belum ditonton
predicted_ratings = model.predict([user_input_array, game_input_array]).flatten()

# Ambil 10 game dengan rating tertinggi
top_ratings_indices = predicted_ratings.argsort()[-10:][::-1]
recommended_game_ids = [games_not_watched[x] for x in top_ratings_indices]

# Gabungkan df dengan game_df berdasarkan 'app_id' untuk mendapatkan title dan tags di df
df_with_game_info = pd.merge(game_df, df[['app_id', 'title', 'tags']], on='app_id', how='left')

# Tampilkan beberapa baris hasil penggabungan
print("Dataframe yang sudah digabungkan (df_with_game_info):")
print(df_with_game_info.head())

# Ambil 10 game yang direkomendasikan
recommended_games = game_df[game_df['app_id'].isin(recommended_game_ids)]

# Gabungkan recommended_games dengan game_df untuk mendapatkan title dan tags
recommended_games_info = pd.merge(recommended_games, df[['app_id', 'title', 'tags']], on='app_id', how='left')

# Tampilkan rekomendasi game dengan informasi lengkap (title dan tags)
print("Top 10 Game Recommendations:")
print(recommended_games_info[['app_id', 'title', 'tags']])

# Menampilkan top 5 game yang telah dirating oleh user
print('-' * 30)
print('Top 5 Games the user has rated:')
print('-' * 30)

top_games_user = (
    game_rated_by_user.sort_values(by='positive_ratio', ascending=False)
    .head(5)
    .app_id.values
)

top_games_info = df[df['app_id'].isin(top_games_user)]
for row in top_games_info.itertuples():
    print(row.title, ':', row.tags)